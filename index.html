<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bandido - è¶Šç‹±å¤§ä½œæˆ˜ (å…¨è®¾å¤‡é€‚é…ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; -webkit-user-select: none; overscroll-behavior: none; }
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        
        .card-shadow { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); }
        
        /* åŠ¨ç”»ç±» */
        .pop-in { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        /* å…³é”®ï¼šç¦ç”¨è§¦æ‘¸æ—¶çš„é»˜è®¤è¡Œä¸ºï¼ˆæ»šåŠ¨ã€ç¼©æ”¾ç­‰ï¼‰ï¼Œäº¤ç”±JSå¤„ç† */
        #game-container { touch-action: none; }
    </style>
</head>
<body class="flex flex-col h-screen bg-gray-900 text-white overflow-hidden">

    <!-- é¡¶éƒ¨æ  -->
    <div class="flex items-center justify-between px-3 py-2 sm:px-4 sm:py-3 bg-gray-800 shadow-lg z-20 shrink-0">
        <div class="flex items-center gap-2 sm:gap-3">
            <div class="bg-orange-600 px-2 py-1 sm:px-3 sm:py-1 rounded-lg font-bold text-lg sm:text-xl tracking-widest shadow-inner">
                BANDIDO
            </div>
            <div class="text-xs sm:text-sm text-gray-400 hidden sm:block">
                å°é”æ‰€æœ‰éš§é“ä»¥é˜»æ­¢è¶Šç‹±
            </div>
        </div>

        <div class="flex items-center gap-2 sm:gap-4">
            <div id="status-exits" class="flex flex-col items-end px-2 py-1 sm:px-3 rounded bg-gray-700 transition-colors duration-300">
                <span class="text-[10px] sm:text-xs text-gray-300 uppercase">å¼€æ”¾å‡ºå£</span>
                <span id="count-exits" class="text-lg sm:text-xl font-bold font-mono text-white">6</span>
            </div>
            
            <div class="flex flex-col items-end px-2 py-1 sm:px-3 bg-gray-700 rounded">
                <span class="text-[10px] sm:text-xs text-gray-300 uppercase">å‰©ä½™ç‰Œå †</span>
                <span id="count-deck" class="text-lg sm:text-xl font-bold font-mono text-blue-200">0</span>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆåŒºåŸŸ -->
    <div id="game-container" class="flex-1 relative overflow-hidden bg-[#1a1a1a] cursor-move" 
         style="background-image: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px;">
        
        <!-- åœ°å›¾å®¹å™¨ (Transformå±‚) -->
        <div id="board-transform" class="absolute origin-center transition-transform duration-75 ease-out" 
             style="width: 3200px; height: 3200px; left: 50%; top: 50%; margin-left: -1600px; margin-top: -1600px;">
             <!-- å¡ç‰Œå’Œæç¤ºå°†é€šè¿‡JSæ’å…¥è¿™é‡Œ -->
        </div>

        <!-- æ‚¬æµ®æ§åˆ¶æŒ‰é’® (é’ˆå¯¹è§¦æ§ä¼˜åŒ–äº†å°ºå¯¸) -->
        <div class="absolute top-4 right-4 flex flex-col gap-3 z-20">
            <button onclick="changeZoom(0.2)" class="p-3 bg-gray-700/80 backdrop-blur hover:bg-gray-600 rounded-full shadow-lg text-white border border-gray-600 active:bg-gray-500 transition-all" title="æ”¾å¤§">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            </button>
            <button onclick="changeZoom(-0.2)" class="p-3 bg-gray-700/80 backdrop-blur hover:bg-gray-600 rounded-full shadow-lg text-white border border-gray-600 active:bg-gray-500 transition-all" title="ç¼©å°">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            </button>
            <button onclick="startNewGame()" class="p-3 bg-red-800/80 backdrop-blur hover:bg-red-700 rounded-full shadow-lg text-white border border-red-700 mt-2 active:bg-red-600 transition-all" title="é‡ç½®æ¸¸æˆ">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
            </button>
        </div>

        <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
        <div id="modal-overlay" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
            <div class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl border border-gray-600 text-center max-w-sm sm:max-w-md w-full animate-[bounceIn_0.5s]">
                <div id="modal-icon" class="text-5xl sm:text-6xl mb-4">ğŸ†</div>
                <h2 id="modal-title" class="text-2xl sm:text-3xl font-bold text-green-400 mb-2">è¶Šç‹±å¤±è´¥ï¼</h2>
                <p id="modal-desc" class="text-sm sm:text-base text-gray-300 mb-6">å¹²å¾—å¥½ï¼Œç‹±è­¦ï¼æ‰€æœ‰å‡ºå£éƒ½å·²è¢«å°é”ã€‚</p>
                <button onclick="startNewGame()" class="w-full sm:w-auto px-6 py-3 bg-orange-600 hover:bg-orange-500 text-white font-bold rounded-full shadow-lg transition-transform transform active:scale-95">
                    å†ç©ä¸€æ¬¡
                </button>
            </div>
        </div>
    </div>

    <!-- åº•éƒ¨æ‰‹ç‰ŒåŒºåŸŸ -->
    <div class="bg-gray-800 border-t border-gray-700 p-2 sm:p-4 z-20 flex flex-col items-center shrink-0 safe-area-bottom">
        <!-- æ§åˆ¶æ  -->
        <div class="w-full max-w-2xl flex justify-between items-center mb-2 px-1">
            <div id="instruction-text" class="text-xs sm:text-sm text-gray-400">é€‰æ‹©ä¸€å¼ å¡ç‰Œ...</div>
            <button id="btn-rotate" onclick="rotateSelectedCard()" disabled 
                class="flex items-center gap-2 px-3 py-2 sm:px-4 sm:py-2 rounded-full font-bold transition-colors bg-gray-700 text-gray-500 cursor-not-allowed text-xs sm:text-sm active:scale-95">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                æ—‹è½¬
            </button>
        </div>

        <!-- æ‰‹ç‰Œåˆ—è¡¨ -->
        <div id="hand-container" class="flex items-center gap-3 sm:gap-4 overflow-x-auto pb-1 w-full justify-center min-h-[85px] sm:min-h-[90px]">
            <!-- æ‰‹ç‰Œå°†é€šè¿‡JSæ’å…¥è¿™é‡Œ -->
        </div>
    </div>

    <!-- é€»è¾‘è„šæœ¬ -->
    <script>
        // --- æ¸¸æˆå¸¸é‡ & é…ç½® ---
        const TILE_SIZE = 80;
        const GRID_SIZE = 40; // è™šæ‹Ÿç½‘æ ¼å¤§å° 40x40
        const CENTER_OFFSET = GRID_SIZE / 2;

        // å¡ç‰Œç±»å‹å®šä¹‰: [ä¸Š, å³, ä¸‹, å·¦] (é¡ºæ—¶é’ˆ) 1=è·¯, 0=å¢™
        const CARD_TYPES = [
            { id: 'I', exits: [1, 0, 1, 0], weight: 10, type: 'normal' },
            { id: 'L', exits: [1, 1, 0, 0], weight: 10, type: 'normal' },
            { id: 'T', exits: [1, 1, 1, 0], weight: 8, type: 'normal' },
            { id: 'X', exits: [1, 1, 1, 1], weight: 5, type: 'normal' },
            { id: 'End', exits: [1, 0, 0, 0], weight: 6, type: 'flashlight' }, // æ­»èƒ¡åŒ
            { id: 'T-Block', exits: [1, 1, 0, 0], weight: 4, type: 'flashlight' }, // çœ‹èµ·æ¥åƒå¼¯é“å…¶å®æ˜¯è·¯éšœ
        ];

        // --- å…¨å±€çŠ¶æ€ ---
        let state = {
            board: {}, // Key: "x,y", Value: { type, exits, rotation, x, y }
            deck: [],
            hand: [],
            selectedCardIdx: null,
            rotation: 0,
            gameStatus: 'playing', // playing, won, lost
            openExits: 0,
            zoom: 1, // åˆå§‹ç¼©æ”¾
            pan: { x: 0, y: 0 }
        };

        // --- åˆå§‹åŒ– & æ¸¸æˆå¾ªç¯ ---
        function startNewGame() {
            let newDeck = [];
            CARD_TYPES.forEach(card => {
                for (let i = 0; i < card.weight; i++) {
                    newDeck.push({ ...card, uniqueId: Math.random().toString(36).substr(2, 9) });
                }
            });
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }

            const initialHand = newDeck.splice(0, 3);

            const startCard = { 
                type: 'normal', 
                exits: [1, 1, 1, 1], 
                rotation: 0, 
                isStart: true,
                x: 0, 
                y: 0 
            };
            
            // é’ˆå¯¹ç§»åŠ¨è®¾å¤‡è°ƒæ•´åˆå§‹ç¼©æ”¾
            const initialZoom = window.innerWidth < 600 ? 0.7 : 1;

            state = {
                board: { "0,0": startCard },
                deck: newDeck,
                hand: initialHand,
                selectedCardIdx: null,
                rotation: 0,
                gameStatus: 'playing',
                openExits: 0,
                zoom: initialZoom,
                pan: { x: 0, y: 0 }
            };

            updateGameState();
            renderAll();
            updateTransform();
        }

        // --- æ ¸å¿ƒé€»è¾‘ ---
        function rotateExits(exits, times) {
            const newExits = [...exits];
            for (let i = 0; i < times; i++) {
                newExits.unshift(newExits.pop());
            }
            return newExits;
        }

        function updateGameState() {
            let openCount = 0;
            const offsets = [[0, -1], [1, 0], [0, 1], [-1, 0]];

            Object.values(state.board).forEach(card => {
                const currentExits = rotateExits(card.exits, card.rotation);
                
                currentExits.forEach((hasExit, dir) => {
                    if (hasExit === 1) {
                        const [dx, dy] = offsets[dir];
                        const neighborKey = `${card.x + dx},${card.y + dy}`;
                        if (!state.board[neighborKey]) {
                            openCount++;
                        }
                    }
                });
            });

            state.openExits = openCount;

            if (openCount === 0) {
                state.gameStatus = 'won';
            } else if (state.deck.length === 0 && state.hand.length === 0) {
                state.gameStatus = 'lost';
            }
        }

        function canPlaceCard(x, y, cardExits, currentRotation) {
            if (state.board[`${x},${y}`]) return false;

            const rotatedExits = rotateExits(cardExits, currentRotation);
            const offsets = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            
            let hasConnection = false;
            let mismatch = false;

            rotatedExits.forEach((mySide, dir) => {
                const [dx, dy] = offsets[dir];
                const neighbor = state.board[`${x + dx},${y + dy}`];

                if (neighbor) {
                    hasConnection = true;
                    const neighborOppositeDir = (dir + 2) % 4;
                    const neighborExits = rotateExits(neighbor.exits, neighbor.rotation);
                    
                    if (mySide !== neighborExits[neighborOppositeDir]) {
                        mismatch = true;
                    }
                }
            });

            return hasConnection && !mismatch;
        }

        function getValidPlacements() {
            if (state.selectedCardIdx === null) return [];
            
            const card = state.hand[state.selectedCardIdx];
            const validSpots = [];
            const candidateKeys = new Set();

            Object.values(state.board).forEach(c => {
                candidateKeys.add(`${c.x},${c.y-1}`);
                candidateKeys.add(`${c.x},${c.y+1}`);
                candidateKeys.add(`${c.x-1},${c.y}`);
                candidateKeys.add(`${c.x+1},${c.y}`);
            });

            candidateKeys.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                if (canPlaceCard(x, y, card.exits, state.rotation)) {
                    validSpots.push({ x, y });
                }
            });
            return validSpots;
        }

        // --- äº¤äº’æ“ä½œ ---
        function selectCard(idx) {
            if (state.selectedCardIdx === idx) {
                state.selectedCardIdx = null;
            } else {
                state.selectedCardIdx = idx;
                state.rotation = 0;
            }
            renderUI();
            renderBoardHints();
        }

        function rotateSelectedCard() {
            if (state.selectedCardIdx === null) return;
            state.rotation = (state.rotation + 1) % 4;
            renderUI();
            renderBoardHints();
        }

        function placeCardAt(x, y) {
            if (state.gameStatus !== 'playing') return;
            const card = state.hand[state.selectedCardIdx];
            
            if (!canPlaceCard(x, y, card.exits, state.rotation)) return;

            state.board[`${x},${y}`] = { ...card, x, y, rotation: state.rotation };

            state.hand.splice(state.selectedCardIdx, 1);
            if (state.deck.length > 0) {
                state.hand.push(state.deck.shift());
            }

            state.selectedCardIdx = null;
            state.rotation = 0;

            updateGameState();
            renderAll();
        }

        // --- æ¸²æŸ“é€»è¾‘ (HTML/SVG ç”Ÿæˆ) ---
        function getCardSVG(card, rotation = 0, size = TILE_SIZE) {
            const center = 50;
            const isFlashlight = card.type === 'flashlight';
            let paths = "";

            const drawSeg = (dir) => {
                if (dir === 0) return `M${center},${center} L${center},0 `;
                if (dir === 1) return `M${center},${center} L${100},${center} `;
                if (dir === 2) return `M${center},${center} L${center},100 `;
                if (dir === 3) return `M${center},${center} L${0},${center} `;
                return "";
            };

            if (card.isStart) {
                paths = `
                    <path d="M50,0 V100 M0,50 H100" stroke="#d97706" stroke-width="22" />
                    <rect x="25" y="25" width="50" height="50" fill="#1f2937" rx="4" />
                    <text x="50" y="55" text-anchor="middle" fill="white" font-size="10" font-family="monospace">JAIL</text>
                    <rect x="25" y="25" width="50" height="50" fill="url(#jailBars)" opacity="0.5"/>
                    <defs><pattern id="jailBars" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M5,0 V10" stroke="#000" stroke-width="2"/></pattern></defs>
                `;
            } else {
                let d = "";
                card.exits.forEach((hasExit, idx) => {
                    if (hasExit) d += drawSeg(idx);
                });
                
                paths += `<path d="${d}" stroke="#d97706" stroke-width="22" stroke-linecap="butt" />`;
                paths += `<path d="${d}" stroke="#f59e0b" stroke-width="16" stroke-linecap="butt" />`;
                
                if (isFlashlight) {
                    paths += `<circle cx="50" cy="50" r="12" fill="#ef4444" stroke="#7f1d1d" stroke-width="3" />`;
                    paths += `<text x="50" y="54" text-anchor="middle" fill="white" font-size="14" font-weight="bold">X</text>`;
                }
            }

            return `
                <div style="width:${size}px; height:${size}px; transform: rotate(${rotation * 90}deg); transition: transform 0.3s;" class="bg-[#2a2a2a] rounded-md overflow-hidden card-shadow border border-gray-700">
                    <svg viewBox="0 0 100 100" class="w-full h-full">
                        <rect width="100" height="100" fill="${card.isStart ? '#4a4a4a' : '#333'}"></rect>
                        ${paths}
                    </svg>
                </div>
            `;
        }

        function renderAll() {
            renderBoardCards();
            renderBoardHints();
            renderUI();
            renderModal();
        }

        function renderBoardCards() {
            const container = document.getElementById('board-transform');
            let html = '';
            
            Object.values(state.board).forEach(card => {
                const left = (CENTER_OFFSET + card.x) * TILE_SIZE;
                const top = (CENTER_OFFSET + card.y) * TILE_SIZE;
                
                html += `
                    <div class="absolute pop-in" style="left:${left}px; top:${top}px;">
                        ${getCardSVG(card, card.rotation)}
                    </div>
                `;
            });
            
            html += `<div id="hints-layer"></div>`;
            container.innerHTML = html;
        }

        function renderBoardHints() {
            const layer = document.getElementById('hints-layer');
            if (!layer) return;

            const spots = getValidPlacements();
            let html = '';

            spots.forEach(spot => {
                const left = (CENTER_OFFSET + spot.x) * TILE_SIZE;
                const top = (CENTER_OFFSET + spot.y) * TILE_SIZE;
                
                // å¢åŠ  touchstart äº‹ä»¶ä»¥åŠ å¿«ç§»åŠ¨ç«¯å“åº”
                html += `
                    <div onclick="placeCardAt(${spot.x}, ${spot.y})"
                         ontouchstart="placeCardAt(${spot.x}, ${spot.y})"
                         class="absolute flex items-center justify-center cursor-pointer z-10 hover:scale-105 transition-transform"
                         style="left:${left}px; top:${top}px; width:${TILE_SIZE}px; height:${TILE_SIZE}px;">
                        <div class="w-[90%] h-[90%] border-4 border-dashed border-green-500 bg-green-500/20 rounded-lg hover:bg-green-500/40"></div>
                    </div>
                `;
            });

            layer.innerHTML = html;
        }

        function renderUI() {
            document.getElementById('count-exits').innerText = state.openExits;
            document.getElementById('count-deck').innerText = state.deck.length;
            
            const statusBox = document.getElementById('status-exits');
            if (state.openExits === 0) {
                statusBox.className = "flex flex-col items-end px-2 py-1 sm:px-3 rounded transition-colors duration-300 bg-green-600";
            } else {
                statusBox.className = "flex flex-col items-end px-2 py-1 sm:px-3 rounded transition-colors duration-300 bg-gray-700";
            }

            const handContainer = document.getElementById('hand-container');
            let handHtml = '';
            
            // ç§»åŠ¨ç«¯å¡ç‰Œå°ºå¯¸è°ƒæ•´
            const cardSize = window.innerWidth < 640 ? 70 : 80;

            if (state.hand.length === 0 && state.deck.length === 0 && state.gameStatus === 'playing') {
                handHtml = '<div class="text-gray-500 italic text-sm">æ— ç‰Œå¯ç”¨...</div>';
            } else {
                state.hand.forEach((card, idx) => {
                    const isSelected = state.selectedCardIdx === idx;
                    const rotation = isSelected ? state.rotation : 0;
                    
                    handHtml += `
                        <div onclick="selectCard(${idx})" class="cursor-pointer transform transition-all duration-200 relative ${isSelected ? '-translate-y-2 sm:-translate-y-4 scale-110 z-10' : 'active:scale-95'}">
                             <div class="${isSelected ? 'ring-2 ring-green-500 rounded-md' : ''}">
                                ${getCardSVG(card, rotation, cardSize)}
                             </div>
                        </div>
                    `;
                });
            }
            handContainer.innerHTML = handHtml;

            const rotateBtn = document.getElementById('btn-rotate');
            const instructText = document.getElementById('instruction-text');
            if (state.selectedCardIdx !== null) {
                rotateBtn.disabled = false;
                rotateBtn.className = "flex items-center gap-2 px-3 py-2 sm:px-4 sm:py-2 rounded-full font-bold transition-colors bg-blue-600 hover:bg-blue-500 text-white shadow-md text-xs sm:text-sm active:scale-95";
                instructText.innerText = "ç‚¹å‡»ç»¿è‰²åŒºåŸŸæ”¾ç½®";
                instructText.className = "text-xs sm:text-sm text-green-400 font-bold animate-pulse";
            } else {
                rotateBtn.disabled = true;
                rotateBtn.className = "flex items-center gap-2 px-3 py-2 sm:px-4 sm:py-2 rounded-full font-bold transition-colors bg-gray-700 text-gray-500 cursor-not-allowed text-xs sm:text-sm";
                instructText.innerText = "é€‰æ‹©ä¸€å¼ å¡ç‰Œ...";
                instructText.className = "text-xs sm:text-sm text-gray-400";
            }
        }

        function renderModal() {
            const modal = document.getElementById('modal-overlay');
            const title = document.getElementById('modal-title');
            const desc = document.getElementById('modal-desc');
            const icon = document.getElementById('modal-icon');

            if (state.gameStatus === 'playing') {
                modal.classList.add('hidden');
            } else {
                modal.classList.remove('hidden');
                if (state.gameStatus === 'won') {
                    icon.innerText = "ğŸ†";
                    title.innerText = "è¶Šç‹±å¤±è´¥ï¼";
                    title.className = "text-2xl sm:text-3xl font-bold text-green-400 mb-2";
                    desc.innerText = "å¹²å¾—å¥½ï¼Œç‹±è­¦ï¼æ‰€æœ‰å‡ºå£éƒ½å·²è¢«å°é”ã€‚";
                } else {
                    icon.innerText = "ğŸƒğŸ’¨";
                    title.innerText = "Bandido é€ƒè„±äº†ï¼";
                    title.className = "text-2xl sm:text-3xl font-bold text-red-400 mb-2";
                    desc.innerText = "ç‰Œå †å·²è€—å°½ï¼Œä½†ä»æœ‰éš§é“æœªå°é”ã€‚";
                }
            }
        }

        // --- è§†å£æ§åˆ¶ (ç»Ÿä¸€é¼ æ ‡ä¸è§¦æ‘¸) ---
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };
        let lastTouchDistance = 0; // ç”¨äºåŒæŒ‡ç¼©æ”¾
        const gameContainer = document.getElementById('game-container');
        const boardTransform = document.getElementById('board-transform');

        function updateTransform() {
            boardTransform.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;
        }

        function changeZoom(delta) {
            state.zoom = Math.max(0.4, Math.min(2.5, state.zoom + delta));
            updateTransform();
        }

        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦» (ç”¨äºPinchç¼©æ”¾)
        function getDistance(t1, t2) {
            return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        }

        // --- é¼ æ ‡äº‹ä»¶ ---
        gameContainer.addEventListener('mousedown', e => {
            isDragging = true;
            lastPos = { x: e.clientX, y: e.clientY };
            gameContainer.style.cursor = 'grabbing';
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            gameContainer.style.cursor = 'move';
        });

        window.addEventListener('mousemove', e => {
            if (!isDragging) return;
            e.preventDefault();
            const dx = e.clientX - lastPos.x;
            const dy = e.clientY - lastPos.y;
            lastPos = { x: e.clientX, y: e.clientY };
            
            state.pan.x += dx;
            state.pan.y += dy;
            updateTransform();
        });

        gameContainer.addEventListener('wheel', e => {
            e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            changeZoom(delta);
        }, { passive: false });

        // --- è§¦æ‘¸äº‹ä»¶ (æ‰‹æœº/å¹³æ¿) ---
        
        gameContainer.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                // å•æŒ‡æ‹–æ‹½å¼€å§‹
                isDragging = true;
                lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                // åŒæŒ‡æåˆå¼€å§‹
                isDragging = false; // æš‚åœæ‹–æ‹½ï¼Œä¼˜å…ˆå¤„ç†ç¼©æ”¾
                lastTouchDistance = getDistance(e.touches[0], e.touches[1]);
            }
        }, { passive: false });

        gameContainer.addEventListener('touchmove', e => {
            e.preventDefault(); // å…³é”®ï¼šé˜»æ­¢æµè§ˆå™¨é»˜è®¤æ»šåŠ¨/ç¼©æ”¾
            
            if (e.touches.length === 1 && isDragging) {
                // å•æŒ‡å¹³ç§»
                const dx = e.touches[0].clientX - lastPos.x;
                const dy = e.touches[0].clientY - lastPos.y;
                lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                
                state.pan.x += dx;
                state.pan.y += dy;
                updateTransform();
            } else if (e.touches.length === 2) {
                // åŒæŒ‡ç¼©æ”¾
                const dist = getDistance(e.touches[0], e.touches[1]);
                if (lastTouchDistance > 0) {
                    const delta = dist - lastTouchDistance;
                    // è°ƒæ•´ç¼©æ”¾çµæ•åº¦
                    const zoomDelta = delta * 0.005; 
                    changeZoom(zoomDelta);
                }
                lastTouchDistance = dist;
            }
        }, { passive: false });

        gameContainer.addEventListener('touchend', e => {
            // å¦‚æœæ‰‹æŒ‡æŠ¬èµ·ï¼Œé‡ç½®çŠ¶æ€
            if (e.touches.length === 0) {
                isDragging = false;
            }
            if (e.touches.length < 2) {
                lastTouchDistance = 0;
            }
            // å¦‚æœå‰©ä¸‹ä¸€æ ¹æ‰‹æŒ‡ï¼Œå°è¯•æ¢å¤æ‹–æ‹½é€»è¾‘ï¼ˆé‡æ–°å®šä½é”šç‚¹ï¼‰
            if (e.touches.length === 1) {
                 lastPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                 isDragging = true;
            }
        });

        // --- å¯åŠ¨æ¸¸æˆ ---
        startNewGame();

        // çª—å£å¤§å°æ”¹å˜æ—¶é€‚é…
        window.addEventListener('resize', () => {
             renderUI();
        });

    </script>
</body>
</html>