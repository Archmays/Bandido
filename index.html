<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bandido - è¶Šç‹±å¤§ä½œæˆ˜ (iOSä¿®å¤ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* * å…³é”®ä¿®å¤ï¼š
         * 1. ä½¿ç”¨ svh (Small Viewport Height) æ›¿ä»£ dvhã€‚svh å§‹ç»ˆæŒ‰åœ°å€æ å­˜åœ¨æ—¶çš„æœ€å°é«˜åº¦è®¡ç®—ï¼Œ
         * é˜²æ­¢ç‚¹å‡»åº•éƒ¨å¯¼è‡´åœ°å€æ æ”¶èµ·æ—¶é¡µé¢é«˜åº¦çªå˜ã€åœ°å›¾ä¹±è·³ã€‚
         * 2. position: fixed + inset: 0 å½»åº•é”æ­»é¡µé¢ï¼Œé˜²æ­¢ iOS æ©¡çš®ç­‹æ»šåŠ¨ã€‚
         */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            user-select: none; 
            -webkit-user-select: none; 
            overscroll-behavior: none; 
            height: 100svh; /* æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ svh ä¿æŒé«˜åº¦ç¨³å®š */
            position: fixed; /* æ ¸å¿ƒä¿®å¤ï¼šé”æ­»è§†å£ */
            inset: 0;
            width: 100vw;
            overflow: hidden;
            background-color: #111827;
        }
        
        /* é€‚é… iPhone X+ åº•éƒ¨å°é»‘æ¡ */
        .safe-pb {
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™æ»šåŠ¨åŠŸèƒ½ */
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        .card-shadow { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5); }
        
        .pop-in { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        
        #game-container { touch-action: none; }
    </style>
</head>
<body class="flex flex-col text-white">

    <!-- é¡¶éƒ¨æ ï¼šç´§å‡‘è®¾è®¡ -->
    <div class="flex items-center justify-between px-3 py-2 bg-gray-800 shadow-lg z-30 shrink-0 relative">
        <div class="flex items-center gap-2">
            <div class="bg-orange-600 px-2 py-1 rounded-lg font-bold text-lg tracking-widest shadow-inner leading-none">
                BANDIDO
            </div>
        </div>

        <div class="flex items-center gap-2">
            <div id="status-exits" class="flex flex-col items-center px-2 py-1 rounded bg-gray-700 transition-colors duration-300 min-w-[60px]">
                <span class="text-[10px] text-gray-400 uppercase leading-none mb-1">å‡ºå£</span>
                <span id="count-exits" class="text-lg font-bold font-mono text-white leading-none">6</span>
            </div>
            
            <div class="flex flex-col items-center px-2 py-1 bg-gray-700 rounded min-w-[60px]">
                <span class="text-[10px] text-gray-400 uppercase leading-none mb-1">å‰©ä½™</span>
                <span id="count-deck" class="text-lg font-bold font-mono text-blue-200 leading-none">0</span>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆåŒºåŸŸï¼šå æ®å‰©ä½™æ‰€æœ‰ç©ºé—´ -->
    <div id="game-container" class="flex-1 relative bg-[#1a1a1a] cursor-move overflow-hidden w-full h-full" 
         style="background-image: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px;">
        
        <!-- åœ°å›¾å®¹å™¨ -->
        <div id="board-transform" class="absolute origin-center transition-transform duration-75 ease-out will-change-transform" 
             style="width: 3200px; height: 3200px; left: 50%; top: 50%; margin-left: -1600px; margin-top: -1600px;">
             <!-- å†…å®¹ç”±JSç”Ÿæˆ -->
        </div>

        <!-- æ‚¬æµ®æŒ‰é’®ç»„ -->
        <div class="absolute top-4 right-4 flex flex-col gap-3 z-20 pointer-events-auto">
            <button onclick="changeZoom(0.2)" class="w-10 h-10 flex items-center justify-center bg-gray-700/90 backdrop-blur rounded-full shadow-lg border border-gray-600 active:bg-gray-500 active:scale-95 transition-all">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            </button>
            <button onclick="changeZoom(-0.2)" class="w-10 h-10 flex items-center justify-center bg-gray-700/90 backdrop-blur rounded-full shadow-lg border border-gray-600 active:bg-gray-500 active:scale-95 transition-all">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            </button>
            <button onclick="startNewGame()" class="w-10 h-10 flex items-center justify-center bg-red-800/90 backdrop-blur rounded-full shadow-lg border border-red-700 mt-2 active:bg-red-600 active:scale-95 transition-all">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
            </button>
        </div>

        <!-- æ¨¡æ€æ¡† -->
        <div id="modal-overlay" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
            <div class="bg-gray-800 p-6 rounded-2xl shadow-2xl border border-gray-600 text-center w-full max-w-sm animate-[bounceIn_0.5s]">
                <div id="modal-icon" class="text-5xl mb-4">ğŸ†</div>
                <h2 id="modal-title" class="text-2xl font-bold text-green-400 mb-2">èƒœåˆ©ï¼</h2>
                <p id="modal-desc" class="text-gray-300 mb-6">æ‰€æœ‰éš§é“å·²å°é”ã€‚</p>
                <button onclick="startNewGame()" class="w-full py-3 bg-orange-600 text-white font-bold rounded-xl shadow-lg active:scale-95 transition-transform">
                    å†ç©ä¸€æ¬¡
                </button>
            </div>
        </div>
    </div>

    <!-- åº•éƒ¨åŒºåŸŸï¼šä½¿ç”¨ safe-pb é€‚é… iPhone åº•éƒ¨ -->
    <!-- æ·»åŠ  touch-action: none é˜²æ­¢åº•éƒ¨åŒºåŸŸç‚¹å‡»è§¦å‘é¡µé¢çº§æ»šåŠ¨ -->
    <div class="bg-gray-800 border-t border-gray-700 z-30 flex flex-col items-center shrink-0 safe-pb relative shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.3)]" style="touch-action: none;">
        
        <!-- æ“ä½œæç¤ºä¸æ—‹è½¬æŒ‰é’® -->
        <div class="w-full flex justify-between items-center px-4 py-2 border-b border-gray-700/50 bg-gray-800/50">
            <div id="instruction-text" class="text-xs text-gray-400 truncate mr-2">é€‰æ‹©å¡ç‰Œ...</div>
            <button id="btn-rotate" onclick="rotateSelectedCard()" disabled 
                class="flex items-center gap-1 pl-3 pr-4 py-1.5 rounded-full font-bold transition-all bg-gray-700 text-gray-500 text-xs active:scale-95 disabled:opacity-50 disabled:active:scale-100 whitespace-nowrap">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                æ—‹è½¬
            </button>
        </div>

        <!-- æ‰‹ç‰Œå®¹å™¨ï¼šä¿è¯é«˜åº¦ï¼Œé˜²æ­¢å¡Œé™· -->
        <!-- æ·»åŠ  touch-action: pan-x æ˜ç¡®å…è®¸æ¨ªå‘æ»šåŠ¨ï¼Œé˜»æ­¢çºµå‘å¹²æ‰° -->
        <div class="w-full overflow-x-auto hide-scrollbar" style="touch-action: pan-x;">
            <div id="hand-container" class="flex items-center justify-center gap-3 px-4 py-3 min-w-full">
                <!-- å¡ç‰Œ -->
            </div>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒé€»è¾‘ ---
        const TILE_SIZE = 80;
        const GRID_SIZE = 40;
        const CENTER_OFFSET = GRID_SIZE / 2;

        const CARD_TYPES = [
            { id: 'I', exits: [1, 0, 1, 0], weight: 10, type: 'normal' },
            { id: 'L', exits: [1, 1, 0, 0], weight: 10, type: 'normal' },
            { id: 'T', exits: [1, 1, 1, 0], weight: 8, type: 'normal' },
            { id: 'X', exits: [1, 1, 1, 1], weight: 5, type: 'normal' },
            { id: 'End', exits: [1, 0, 0, 0], weight: 6, type: 'flashlight' },
            { id: 'T-Block', exits: [1, 1, 0, 0], weight: 4, type: 'flashlight' },
        ];

        let state = {
            board: {}, deck: [], hand: [],
            selectedCardIdx: null, rotation: 0,
            gameStatus: 'playing', openExits: 0,
            zoom: 1, pan: { x: 0, y: 0 }
        };

        function startNewGame() {
            let newDeck = [];
            CARD_TYPES.forEach(card => {
                for (let i = 0; i < card.weight; i++) newDeck.push({ ...card, uniqueId: Math.random().toString(36).substr(2, 9) });
            });
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }

            const initialHand = newDeck.splice(0, 3);
            const startCard = { type: 'normal', exits: [1, 1, 1, 1], rotation: 0, isStart: true, x: 0, y: 0 };
            
            // ç§»åŠ¨ç«¯åˆå§‹ç¼©æ”¾è°ƒæ•´
            const isMobile = window.innerWidth < 640;
            const initialZoom = isMobile ? 0.65 : 1;

            state = {
                board: { "0,0": startCard }, deck: newDeck, hand: initialHand,
                selectedCardIdx: null, rotation: 0,
                gameStatus: 'playing', openExits: 0,
                zoom: initialZoom, pan: { x: 0, y: 0 }
            };

            updateGameState();
            renderAll();
            updateTransform();
        }

        function rotateExits(exits, times) {
            const newExits = [...exits];
            for (let i = 0; i < times; i++) newExits.unshift(newExits.pop());
            return newExits;
        }

        function updateGameState() {
            let openCount = 0;
            const offsets = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            Object.values(state.board).forEach(card => {
                const currentExits = rotateExits(card.exits, card.rotation);
                currentExits.forEach((hasExit, dir) => {
                    if (hasExit === 1) {
                        const [dx, dy] = offsets[dir];
                        if (!state.board[`${card.x + dx},${card.y + dy}`]) openCount++;
                    }
                });
            });
            state.openExits = openCount;
            if (openCount === 0) state.gameStatus = 'won';
            else if (state.deck.length === 0 && state.hand.length === 0) state.gameStatus = 'lost';
        }

        function canPlaceCard(x, y, cardExits, currentRotation) {
            if (state.board[`${x},${y}`]) return false;
            const rotatedExits = rotateExits(cardExits, currentRotation);
            const offsets = [[0, -1], [1, 0], [0, 1], [-1, 0]];
            let hasConnection = false, mismatch = false;

            rotatedExits.forEach((mySide, dir) => {
                const [dx, dy] = offsets[dir];
                const neighbor = state.board[`${x + dx},${y + dy}`];
                if (neighbor) {
                    hasConnection = true;
                    const neighborOppositeDir = (dir + 2) % 4;
                    const neighborExits = rotateExits(neighbor.exits, neighbor.rotation);
                    if (mySide !== neighborExits[neighborOppositeDir]) mismatch = true;
                }
            });
            return hasConnection && !mismatch;
        }

        function getValidPlacements() {
            if (state.selectedCardIdx === null) return [];
            const card = state.hand[state.selectedCardIdx];
            const validSpots = [];
            const candidateKeys = new Set();
            Object.values(state.board).forEach(c => {
                candidateKeys.add(`${c.x},${c.y-1}`);
                candidateKeys.add(`${c.x},${c.y+1}`);
                candidateKeys.add(`${c.x-1},${c.y}`);
                candidateKeys.add(`${c.x+1},${c.y}`);
            });
            candidateKeys.forEach(key => {
                const [x, y] = key.split(',').map(Number);
                if (canPlaceCard(x, y, card.exits, state.rotation)) validSpots.push({ x, y });
            });
            return validSpots;
        }

        function selectCard(idx) {
            state.selectedCardIdx = (state.selectedCardIdx === idx) ? null : idx;
            state.rotation = 0;
            renderUI();
            renderBoardHints();
        }

        function rotateSelectedCard() {
            if (state.selectedCardIdx === null) return;
            state.rotation = (state.rotation + 1) % 4;
            renderUI();
            renderBoardHints();
        }

        function placeCardAt(x, y) {
            if (state.gameStatus !== 'playing') return;
            const card = state.hand[state.selectedCardIdx];
            if (!canPlaceCard(x, y, card.exits, state.rotation)) return;

            state.board[`${x},${y}`] = { ...card, x, y, rotation: state.rotation };
            state.hand.splice(state.selectedCardIdx, 1);
            if (state.deck.length > 0) state.hand.push(state.deck.shift());
            
            state.selectedCardIdx = null;
            state.rotation = 0;
            updateGameState();
            renderAll();
        }

        // SVG ç”Ÿæˆä¼˜åŒ–
        function getCardSVG(card, rotation = 0, size = TILE_SIZE) {
            const center = 50;
            let paths = "";
            const drawSeg = (dir) => {
                if (dir === 0) return `M${center},${center} L${center},0 `;
                if (dir === 1) return `M${center},${center} L${100},${center} `;
                if (dir === 2) return `M${center},${center} L${center},100 `;
                if (dir === 3) return `M${center},${center} L${0},${center} `;
                return "";
            };

            if (card.isStart) {
                paths = `<path d="M50,0 V100 M0,50 H100" stroke="#ea580c" stroke-width="22" />
                        <rect x="25" y="25" width="50" height="50" fill="#1f2937" rx="4" />
                        <text x="50" y="55" text-anchor="middle" fill="white" font-size="10" font-family="monospace">JAIL</text>
                        <rect x="25" y="25" width="50" height="50" fill="url(#jailBars-${card.uniqueId})" opacity="0.5"/>
                        <defs><pattern id="jailBars-${card.uniqueId}" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M5,0 V10" stroke="#000" stroke-width="2"/></pattern></defs>`;
            } else {
                let d = "";
                card.exits.forEach((hasExit, idx) => { if (hasExit) d += drawSeg(idx); });
                paths += `<path d="${d}" stroke="#ea580c" stroke-width="22" stroke-linecap="butt" />`;
                paths += `<path d="${d}" stroke="#fb923c" stroke-width="16" stroke-linecap="butt" />`;
                if (card.type === 'flashlight') {
                    paths += `<circle cx="50" cy="50" r="12" fill="#ef4444" stroke="#7f1d1d" stroke-width="3" />
                              <text x="50" y="54" text-anchor="middle" fill="white" font-size="14" font-weight="bold">X</text>`;
                }
            }

            return `<div style="width:${size}px; height:${size}px; transform: rotate(${rotation * 90}deg); transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);" 
                        class="bg-[#2a2a2a] rounded-lg overflow-hidden card-shadow border border-gray-700 flex-shrink-0">
                        <svg viewBox="0 0 100 100" class="w-full h-full">
                            <rect width="100" height="100" fill="${card.isStart ? '#4a4a4a' : '#333'}"></rect>
                            ${paths}
                        </svg>
                    </div>`;
        }

        function renderAll() {
            renderBoardCards();
            renderBoardHints();
            renderUI();
            renderModal();
        }

        function renderBoardCards() {
            const container = document.getElementById('board-transform');
            let html = '';
            Object.values(state.board).forEach(card => {
                const left = (CENTER_OFFSET + card.x) * TILE_SIZE;
                const top = (CENTER_OFFSET + card.y) * TILE_SIZE;
                html += `<div class="absolute pop-in" style="left:${left}px; top:${top}px;">${getCardSVG(card, card.rotation)}</div>`;
            });
            html += `<div id="hints-layer"></div>`;
            container.innerHTML = html;
        }

        function renderBoardHints() {
            const layer = document.getElementById('hints-layer');
            if (!layer) return;
            const spots = getValidPlacements();
            let html = '';
            spots.forEach(spot => {
                const left = (CENTER_OFFSET + spot.x) * TILE_SIZE;
                const top = (CENTER_OFFSET + spot.y) * TILE_SIZE;
                html += `<div onclick="placeCardAt(${spot.x}, ${spot.y})" ontouchstart="placeCardAt(${spot.x}, ${spot.y})"
                         class="absolute flex items-center justify-center cursor-pointer z-10 animate-pulse"
                         style="left:${left}px; top:${top}px; width:${TILE_SIZE}px; height:${TILE_SIZE}px;">
                        <div class="w-[90%] h-[90%] border-4 border-dashed border-green-500 bg-green-500/20 rounded-lg"></div></div>`;
            });
            layer.innerHTML = html;
        }

        function renderUI() {
            document.getElementById('count-exits').innerText = state.openExits;
            document.getElementById('count-deck').innerText = state.deck.length;
            
            const statusBox = document.getElementById('status-exits');
            statusBox.className = `flex flex-col items-center px-2 py-1 rounded transition-colors duration-300 min-w-[60px] ${state.openExits === 0 ? 'bg-green-600' : 'bg-gray-700'}`;

            const handContainer = document.getElementById('hand-container');
            let handHtml = '';
            const cardSize = 72; // å›ºå®šæ‰‹ç‰Œå¤§å°ï¼Œé€‚åº”ç§»åŠ¨ç«¯

            if (state.hand.length === 0 && state.deck.length === 0 && state.gameStatus === 'playing') {
                handHtml = '<div class="text-gray-500 italic text-xs">æ— ç‰Œå¯ç”¨...</div>';
            } else {
                state.hand.forEach((card, idx) => {
                    const isSelected = state.selectedCardIdx === idx;
                    const rotation = isSelected ? state.rotation : 0;
                    handHtml += `<div onclick="selectCard(${idx})" class="cursor-pointer transform transition-all duration-200 relative flex-shrink-0 ${isSelected ? '-translate-y-2 scale-110 z-10' : 'active:scale-95'}">
                                    <div class="${isSelected ? 'ring-2 ring-green-500 rounded-lg shadow-[0_0_15px_rgba(74,222,128,0.5)]' : ''}">
                                        ${getCardSVG(card, rotation, cardSize)}
                                    </div>
                                </div>`;
                });
            }
            handContainer.innerHTML = handHtml;

            const rotateBtn = document.getElementById('btn-rotate');
            const instructText = document.getElementById('instruction-text');
            if (state.selectedCardIdx !== null) {
                rotateBtn.disabled = false;
                rotateBtn.className = "flex items-center gap-1 pl-3 pr-4 py-1.5 rounded-full font-bold transition-all bg-blue-600 text-white shadow-md text-xs active:scale-95 whitespace-nowrap";
                instructText.innerText = "ç‚¹å‡»ç»¿è‰²åŒºåŸŸæ”¾ç½®";
                instructText.className = "text-xs text-green-400 font-bold animate-pulse truncate mr-2";
            } else {
                rotateBtn.disabled = true;
                rotateBtn.className = "flex items-center gap-1 pl-3 pr-4 py-1.5 rounded-full font-bold transition-all bg-gray-700 text-gray-500 cursor-not-allowed text-xs whitespace-nowrap";
                instructText.innerText = "é€‰æ‹©ä¸€å¼ å¡ç‰Œ...";
                instructText.className = "text-xs text-gray-400 truncate mr-2";
            }
        }

        function renderModal() {
            const modal = document.getElementById('modal-overlay');
            const title = document.getElementById('modal-title');
            const desc = document.getElementById('modal-desc');
            const icon = document.getElementById('modal-icon');

            if (state.gameStatus === 'playing') {
                modal.classList.add('hidden');
            } else {
                modal.classList.remove('hidden');
                if (state.gameStatus === 'won') {
                    icon.innerText = "ğŸ†";
                    title.innerText = "è¶Šç‹±å¤±è´¥ï¼"; title.className = "text-2xl font-bold text-green-400 mb-2";
                    desc.innerText = "å¹²å¾—å¥½ï¼Œç‹±è­¦ï¼æ‰€æœ‰å‡ºå£éƒ½å·²è¢«å°é”ã€‚";
                } else {
                    icon.innerText = "ğŸƒğŸ’¨";
                    title.innerText = "Bandido é€ƒè„±äº†ï¼"; title.className = "text-2xl font-bold text-red-400 mb-2";
                    desc.innerText = "ç‰Œå †å·²è€—å°½ï¼Œä½†ä»æœ‰éš§é“æœªå°é”ã€‚";
                }
            }
        }

        // --- è§¦æ§ä¸é¼ æ ‡äº‹ä»¶ ---
        let isDragging = false, lastPos = {x:0, y:0}, lastTouchDistance = 0;
        const gameContainer = document.getElementById('game-container');
        const boardTransform = document.getElementById('board-transform');

        function updateTransform() {
            boardTransform.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.zoom})`;
        }
        function changeZoom(delta) {
            state.zoom = Math.max(0.3, Math.min(2.5, state.zoom + delta));
            updateTransform();
        }
        function getDistance(t1, t2) { return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY); }

        gameContainer.addEventListener('mousedown', e => { isDragging = true; lastPos = {x:e.clientX, y:e.clientY}; gameContainer.style.cursor='grabbing'; });
        window.addEventListener('mouseup', () => { isDragging = false; gameContainer.style.cursor='move'; });
        window.addEventListener('mousemove', e => {
            if (!isDragging) return; e.preventDefault();
            state.pan.x += e.clientX - lastPos.x; state.pan.y += e.clientY - lastPos.y;
            lastPos = {x:e.clientX, y:e.clientY}; updateTransform();
        });
        gameContainer.addEventListener('wheel', e => { e.preventDefault(); changeZoom(e.deltaY>0?-0.1:0.1); }, {passive:false});
        
        gameContainer.addEventListener('touchstart', e => {
            if (e.touches.length === 1) { isDragging = true; lastPos = {x:e.touches[0].clientX, y:e.touches[0].clientY}; }
            else if (e.touches.length === 2) { isDragging = false; lastTouchDistance = getDistance(e.touches[0], e.touches[1]); }
        }, {passive:false});
        gameContainer.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 1 && isDragging) {
                state.pan.x += e.touches[0].clientX - lastPos.x; state.pan.y += e.touches[0].clientY - lastPos.y;
                lastPos = {x:e.touches[0].clientX, y:e.touches[0].clientY}; updateTransform();
            } else if (e.touches.length === 2) {
                const dist = getDistance(e.touches[0], e.touches[1]);
                if (lastTouchDistance > 0) changeZoom((dist - lastTouchDistance) * 0.005);
                lastTouchDistance = dist;
            }
        }, {passive:false});
        gameContainer.addEventListener('touchend', e => {
            if (e.touches.length === 0) isDragging = false;
            if (e.touches.length === 1) { lastPos = {x:e.touches[0].clientX, y:e.touches[0].clientY}; isDragging = true; }
        });

        startNewGame();
        window.addEventListener('resize', renderUI);
    </script>
</body>
</html>